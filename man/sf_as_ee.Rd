% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sf_as_ee.R
\name{sf_as_ee}
\alias{sf_as_ee}
\title{Convert an sf object to an EE object}
\usage{
sf_as_ee(
  x,
  via = "getInfo",
  assetId = NULL,
  bucket = NULL,
  overwrite = TRUE,
  monitoring = TRUE,
  check_ring_dir = FALSE,
  evenOdd = TRUE,
  proj = 4326,
  geodesic = NULL,
  quiet = FALSE,
  ...
)
}
\arguments{
\item{x}{sf object to be converted into an ee$FeatureCollection.}

\item{via}{Character. Upload method for sf objects. Three methods are
implemented 'getInfo', 'getInfo_to_asset' and 'gcs_to_asset'. See details.}

\item{assetId}{Character. Destination asset ID for the uploaded file. Ignore
if \code{via} argument is "getInfo".}

\item{bucket}{Character. Name of the bucket (GCS) to save intermediate files
(ignore if \code{via} is not defined as "gcs_to_asset").}

\item{overwrite}{A boolean argument which indicates indicating
whether "filename" should be overwritten. By default TRUE.}

\item{monitoring}{Logical. Ignore if via is not set as
\code{getInfo_to_asset} or \code{gcs_to_asset}. If TRUE the exportation task
will be monitored.}

\item{check_ring_dir}{Logical. See \link[sf]{st_read} for details.}

\item{evenOdd}{Logical. Ignored if \code{x} is not a Polygon. If TRUE,
polygon interiors will be determined by the even/odd rule, where a point
is inside if it crosses an odd number of edges to reach a point at infinity.
Otherwise polygons use the left-inside rule, where interiors are on the
left side of the shell's edges when walking the vertices in the given order.
If unspecified, defaults to TRUE.}

\item{proj}{Integer or character. Coordinate Reference System (CRS) for the
EE object, defaults to "EPSG:4326" (x=longitude, y=latitude).}

\item{geodesic}{Logical. Ignored if \code{x} is not a Polygon or LineString.
Whether line segments should be interpreted as spherical geodesics. If
FALSE, indicates that line segments should be interpreted as planar lines
in the specified CRS. If absent, defaults to TRUE if the CRS is geographic
(including the default EPSG:4326), or to FALSE if the CRS is projected.}

\item{quiet}{Logical. Suppress info message.}

\item{...}{\link[sf]{st_read} arguments might be included.}
}
\value{
An ee$FeatureCollection object
}
\description{
Convert an sf object to an ee$FeatureCollection
}
\details{
\code{sf_as_ee} supports the upload of \code{sf} objects by three different
options: "getInfo", "getInfo_to_asset", and "gcs_to_asset".
When "getInfo" is set in the \code{via} argument the sf object is
transformed to GeoJSON (using \link[geojsonio]{geojson_json}) and then
encrusted in an HTTP request using the server-side objects that are
implemented in the Earth Engine API (ee$Geometry). If the sf object is too
large (~ >1Mb) it is likely to cause bottlenecks since it is a temporary
file that will save in the request message not in their EE Assets. See
\href{https://developers.google.com/earth-engine/client_server}{Client
vs Server} documentation for more details. The second method implemented is
'getInfo_to_asset'. It is similar to the previous one, with the difference
that the result will be saved in your Earth Engine Asset. For dealing
with very large spatial objects is preferable to use the third option
'gcs_to_asset'. This option firstly saves the sf object as a *.shp file
in the /temp directory. Secondly, using the function \code{local_to_gcs}
will move the shapefile from local to Google Cloud Storage. Finally, using
the function \code{gcs_to_ee_table} the ESRI shapefile will be loaded
to their EE Assets.
See \href{https://developers.google.com/earth-engine/importing}{Importing
table data} documentation for more details.

Earth Engine is strict on polygon ring directions (outer ring
counter-clockwise, and the inner one clockwise). If \code{check_ring_dir} is TRUE,
it checks every ring, and revert them if necessary, to counter clockwise for
outer, and clockwise for inner (hole) ones. By default, this is FALSE because
it is an expensive operation.
}
\examples{
\donttest{
library(rgee)
library(sf)

ee_reattach() # reattach ee as a reserved word
ee_Initialize()

# 1. Handling geometry parameters
# Simple
ee_x <- st_read(system.file("shape/nc.shp", package = "sf")) \%>\%
  sf_as_ee()

Map$centerObject(eeObject = ee_x)
Map$addLayer(ee_x)

# Create a right-inside polygon.
toy_poly <- matrix(data = c(-35,-10,-35,10,35,10,35,-10,-35,-10),
                   ncol = 2,
                   byrow = TRUE) \%>\%
  list() \%>\%
  st_polygon()
holePoly <- sf_as_ee(x = toy_poly, evenOdd = FALSE)

# Create an even-odd version of the polygon.
evenOddPoly <- sf_as_ee(toy_poly, evenOdd = TRUE)

# Create a point to test the insideness of the polygon.
pt <- ee$Geometry$Point(c(1.5, 1.5))

# Check insideness with a contains operator.
print(holePoly$geometry()$contains(pt)$getInfo() \%>\% ee_utils_py_to_r())
print(evenOddPoly$geometry()$contains(pt)$getInfo() \%>\% ee_utils_py_to_r())

# 2. Upload small geometries to EE asset
assetId <- sprintf("\%s/\%s", ee_get_assethome(), 'toy_poly')
eex <- sf_as_ee(
  x = toy_poly,
  overwrite = TRUE,
  assetId = assetId,
  via = 'getInfo_to_asset')

# 3. Upload large geometries to EE asset
ee_Initialize(gcs = TRUE)
assetId <- sprintf("\%s/\%s", ee_get_assethome(), 'toy_poly_gcs')
eex <- sf_as_ee(
  x = toy_poly,
  overwrite = TRUE,
  assetId = assetId,
  bucket = 'rgee_dev',
  monitoring = FALSE,
  via = 'gcs_to_asset'
)
}
}
